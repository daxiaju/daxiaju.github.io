<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何让github pages站点使用自定义域名</title>
      <link href="/2023/11/30/github-pages-custom-domain/"/>
      <url>/2023/11/30/github-pages-custom-domain/</url>
      
        <content type="html"><![CDATA[<p>Github Pages 提供了一个免费的静态文件托管服务，方便我们搭建在线技术文档，甚至是假设博客。<br>同时 Github还免费提供了 <code>xxx.github.io</code> 三级域名用于访问。但是如果我们希望自己的站点更具个性化，我们可以自己注册域名并在github上开启自定义域名。</p><p>下面跟大虾一起完成设置吧。</p><h1 id="一、注册域名并修改DNS记录"><a href="#一、注册域名并修改DNS记录" class="headerlink" title="一、注册域名并修改DNS记录"></a>一、注册域名并修改DNS记录</h1><p>首先在域名注册商处注册一个域名，然后修改域名的DNS记录，将域名解析到Github Pages的服务器上。</p><p>添加一个C记录<code>www</code>， 解析到 <code>xxx.github.io.</code> 三级域名，注意这里xxx必须是github上注册的user或者orgnization名字。</p><p><img src="/images/domain_c_name.jpg" alt="image"></p><h1 id="二、在Github上完成域名认证"><a href="#二、在Github上完成域名认证" class="headerlink" title="二、在Github上完成域名认证"></a>二、在Github上完成域名认证</h1><p>在github右上角点击个人图标，进入settings页面。</p><p>Settings页面左侧 Code, Plan and automation栏下进入Pages页面。</p><p>这里需要添加上自定义的域名并验证改域名为你所有。</p><p>点击添加域名，把你的域名添加进去。注意这里只需要输入二级域名。</p><p>添加完成后需要在DNS解析中加入一个TXT记录，用于验证域名所有权。</p><p><img src="/images/verify_domain.jpg" alt="image"></p><p><img src="/images/verify_domain2.jpg" alt="image"></p><p>将该页面上提示的TXT记录和值添加到域名的DNS记录中。</p><p><img src="/images/verify_domain3.jpg" alt="image"></p><p>修改DNS记录可能要等几分钟只几个小时等待生效，生效后点击Verify即可完成认证。</p><p><img src="/images/verify_domain4.jpg" alt="image"></p><h1 id="3-在Github-Pages站点后台绑定域名"><a href="#3-在Github-Pages站点后台绑定域名" class="headerlink" title="3 在Github Pages站点后台绑定域名"></a>3 在Github Pages站点后台绑定域名</h1><p>回到指定的Github Pages站点项目后台，点击Settings。</p><p>找到Custom domain栏，输入自己的域名，点击Save。</p><p>此处设置完成后github可能需要花一些时间等待域名正确解析。</p><p><img src="/images/github_pages_domain.jpg" alt="image"></p><p>这里勾选HTTPS后github pages还可以为你的域名生成SSL证书，省去自己申请证书的麻烦，非常贴心。</p><p>等到解析完成，通过 xxx.github.io即可访问自己的网站了。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages">https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/verifying-your-custom-domain-for-github-pages</a></p><p><a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site">https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Pages </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python给每个类指定logger</title>
      <link href="/2021/07/30/python-logging-for-class/"/>
      <url>/2021/07/30/python-logging-for-class/</url>
      
        <content type="html"><![CDATA[<p>通常我们在python中使用<code>logging.getLogger(__name__)</code>方式获取logger，可以得到一个module层次的logger，但是如果我们一个module中有多个class，怎么区分是哪一个class写入的日志呢，最好能有一个class级别的logger。</p><h1 id="方法一：在-init-中初始化"><a href="#方法一：在-init-中初始化" class="headerlink" title="方法一：在__init__中初始化"></a>方法一：在__init__中初始化</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.logger = logging.getLogger(self.__class__.__module__ + <span class="string">&#x27;.&#x27;</span> + self.__class__.__qualname__)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        self.logger.warning(<span class="string">&#x27;do_something&#x27;</span>)</span><br></pre></td></tr></table></figure><p>方法一的写法需要每个类都加入重复的代码，比较啰嗦，而且调用元方法影响代码美观，所以可以考虑运用python多重继承机制，继承一个带有logger的类。</p><h1 id="方法二：继承"><a href="#方法二：继承" class="headerlink" title="方法二：继承"></a>方法二：继承</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMixin</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.logger = logging.getLogger(self.__class__.__module__ + <span class="string">&#x27;.&#x27;</span> + self.__class__.__qualname__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>(LoggingMixin, Base):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Example, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        self.logger.info(<span class="string">&#x27;do_something&#x27;</span>)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line">e = Example()</span><br><span class="line">e.do_something()</span><br></pre></td></tr></table></figure><p>第二种方法更能提现OO即面向对象编程的思想，避免了重复，通过继承完成重用。</p><p>但是这种方法有个缺陷，python多重继承时会只继承第一个构造函数（按MRO顺序，可以简单理解为从左到右），如果mixin写在继承顺序的左侧，则右侧的基类构造函数会失效。</p><p>例如Base类也有构造函数，写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则Base的__init__始终不会被调用。</p><h1 id="方法三：延迟加载logger"><a href="#方法三：延迟加载logger" class="headerlink" title="方法三：延迟加载logger"></a>方法三：延迟加载logger</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingMixin</span>:</span><br><span class="line">    _logger = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">logger</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._logger <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._logger = logging.getLogger(self.__class__.__module__ + <span class="string">&#x27;.&#x27;</span> + self.__class__.__qualname__)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self._logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.name = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>(LoggingMixin, Base):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Example, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        self.logger.info(<span class="string">&#x27;do_something %s&#x27;</span>, self.name)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br><span class="line">e = Example()</span><br><span class="line">e.do_something()</span><br><span class="line"></span><br><span class="line"><span class="comment"># INFO:__main__.Example:do_something</span></span><br></pre></td></tr></table></figure><p>这样mixin中只声明成员，在调用时延迟加载，则可以不依赖构造函数，不会影响程序的继承结构。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.python.org/3/library/logging.html#logger-objects">https://docs.python.org/3/library/logging.html#logger-objects</a></p><p><a href="https://stackoverflow.com/questions/2020014/get-fully-qualified-class-name-of-an-object-in-python">https://stackoverflow.com/questions/2020014/get-fully-qualified-class-name-of-an-object-in-python</a></p><p><a href="https://blog.csdn.net/weixin_40636692/article/details/79940501?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/weixin_40636692/article/details/79940501?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ansible修改系统级别的path环境变量</title>
      <link href="/2020/11/26/modify-system-wide-path-variable-with-ansible/"/>
      <url>/2020/11/26/modify-system-wide-path-variable-with-ansible/</url>
      
        <content type="html"><![CDATA[<p>使用ansible在受控节点上安装软件，经常会碰到需要修改path环境变量的问题，那么如何能有效且幂等地修改path变量呢，今天虾哥就来分享一下。</p><p>下面的一个例子，在centos 7 上安装python3之后，python3上新安装包的可执行文件会链接在&#x2F;usr&#x2F;local&#x2F;bin下，但是默认情况下这个路径没有放在path变量中。</p><p>下面的playbook使用pip3安装uwsgi，并将&#x2F;usr&#x2F;local&#x2F;bin添加到path变量中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">uwsgi</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">python3</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> </span><br><span class="line">          <span class="bullet">-</span> <span class="string">python3</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">uwsgi</span></span><br><span class="line">      <span class="attr">pip:</span></span><br><span class="line">        <span class="attr">executable:</span> <span class="string">pip3</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">uwsgi</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Uwsgi</span> <span class="string">env</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          export PATH=$PATH:/usr/local/bin</span></span><br><span class="line"><span class="string"></span>        <span class="attr">dest:</span> <span class="string">/etc/profile.d/uwsgi.sh</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">644</span></span><br><span class="line">      <span class="attr">become:</span> <span class="literal">yes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其原理非常简单，就是在<code>/etc/profile.d</code>文件夹下新建一个shell脚本，脚本中修改path变量。<br>用户在新登录时会执行这个文件夹下的所有文件，这样就获得了最新的path变量了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/46936896/how-to-set-existing-linux-environment-variables-with-ansible">https://stackoverflow.com/questions/46936896/how-to-set-existing-linux-environment-variables-with-ansible</a></li><li><a href="https://stackoverflow.com/questions/56560173/ansible-how-to-add-modify-path-variable-in-centos">https://stackoverflow.com/questions/56560173/ansible-how-to-add-modify-path-variable-in-centos</a></li><li><a href="https://www.jeffgeerling.com/blog/2017/add-path-global-path-ansible">https://www.jeffgeerling.com/blog/2017/add-path-global-path-ansible</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
            <tag> centos 7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用免费的ShareX实现录屏</title>
      <link href="/2020/11/25/use-sharex-to-record-screen/"/>
      <url>/2020/11/25/use-sharex-to-record-screen/</url>
      
        <content type="html"><![CDATA[<p>日常工作学习中免不了需要用到截屏或录屏功能，今天就来推荐一款免费开源的截图工具，ShareX。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><img src="/images/sharex1.png"></p><p><img src="/images/sharex2.png"></p><p><img src="/images/sharex3.png"></p><p>除了基本的截图功能外，还可以在截图后自动上传，自行预设动作，有很灵活的配置潜力。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>官网地址为：<a href="https://getsharex.com/">https://getsharex.com/</a></p><p>当前最新版本下载地址如下：</p><p><a href="https://github.com/ShareX/ShareX/releases/download/v13.3.0/ShareX-13.3.0-setup.exe">https://github.com/ShareX/ShareX/releases/download/v13.3.0/ShareX-13.3.0-setup.exe</a></p><p>安装完直接在开始菜单启动即可。</p><h1 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h1><h2 id="录制GIF"><a href="#录制GIF" class="headerlink" title="录制GIF"></a>录制GIF</h2><p>要录制GIF需要执行以下步骤</p><ol><li>快捷动作-屏幕录制(GIF) 或按快捷键 Ctrl + Shift + Print Screen</li><li>选择需要录制的范围，此时录制开始</li><li>录制开始后有个选择框，下面有停止按钮，点击停止结束录制。</li><li>录制完成后文件会自动出现在程序主界面。</li></ol><p><img src="/images/sharex4.gif"></p><h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><p>录制视频可以提供更高的帧数、更长的录制时间以及音频内录。ShareX录制视频使用ffmpeg库实现，并提供了内录所需的虚拟设备插件，在使用前需要进行设置。</p><h3 id="ffmpeg设置"><a href="#ffmpeg设置" class="headerlink" title="ffmpeg设置"></a>ffmpeg设置</h3><p>点击菜单 <code>动作设置 - 屏幕记录 - 屏幕录制选项</code></p><p>在<code>FFmegp路径</code>选项框右侧有<code>下载</code>按钮，点击即可自动下载。</p><p>自动下载速度较慢，可以自行下载相关程序，<a href="https://ffmpeg.org/download.html">官网地址</a></p><p>windows直接下载地址 </p><p><a href="https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-full.7z">https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-full.7z</a></p><p>下载并解压后把ffmpeg.exe路径填写在框里。</p><p><img src="/images/sharex5.png"></p><h3 id="安装虚拟设备"><a href="#安装虚拟设备" class="headerlink" title="安装虚拟设备"></a>安装虚拟设备</h3><p>要录制屏幕和音频，需要安装虚拟设备，可以通过sharex自动安装。</p><p>还是在屏幕录制选项页面 <code>动作设置 - 屏幕记录 - 屏幕录制选项</code></p><p>点击“安装捕捉器”按钮，点击下一步安装程序即可。</p><p><img src="/images/sharex6.png"></p><p>安装完成后，在设备中选择新安装的虚拟设备。</p><p><img src="/images/sharex5.gif"></p><p>这样就设置完成了。</p><h3 id="屏幕录制"><a href="#屏幕录制" class="headerlink" title="屏幕录制"></a>屏幕录制</h3><ol><li>快捷动作-屏幕录制 或按快捷键 Shift + Print Screen</li><li>选择需要录制的范围，此时录制开始</li><li>录制开始后有个选择框，下面有停止按钮，点击停止结束录制。</li><li>录制完成后文件会自动出现在程序主界面。</li></ol><p><img src="/images/sharex6.gif"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vagrant同步Ansible开发文件夹</title>
      <link href="/2020/11/19/vagrant-ansible-develop-folder-sync/"/>
      <url>/2020/11/19/vagrant-ansible-develop-folder-sync/</url>
      
        <content type="html"><![CDATA[<p>要在windows下开发*nux程序，vagrant是一个不可多得的好帮手，随时可以创建一个指定的虚拟机环境，还可以把虚拟机环境配置提交到版本控制库，跟伙伴一起分享。</p><p>一般vagrant会把当前文件夹映射到虚拟机中的&#x2F;vagrant，实时共享。所以我们通常在宿主机修改源代码文件，在客户机中编译和运行。</p><p>但是要开发ansible，默认的vagrant配置就无法满足需求了。因为ansible出于安全考虑，在运行时会检查脚本文件夹权限，如果有公共写权限的话就会忽略当前文件夹下的ansible.cfg运行。</p><p><img src="/images/vagrant-ansible-persssion-ignore.png"></p><blockquote><p>[WARNING] Ansible is being run in a world writable directory (&#x2F;vagrant), ignoring it as an ansible.cfg source. For more information see <a href="https://docs.ansible.com/ansible/devel/reference_appendices/config.html#cfg-in-world-writable-dir">https://docs.ansible.com/ansible/devel/reference_appendices/config.html#cfg-in-world-writable-dir</a></p></blockquote><p>由于vagrant使用的使虚拟机的目录映射功能，在这个模式下无法通过chmod修改文件夹的读写权限。</p><p>那么是不是就没办法了呢，非也，下面虾哥就分享一下如何能既确保源码文件夹符合ansible权限要求，又能在宿主机和客户机之间共享文件。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>vagrant默认共享其实等价于隐式声明了一个sync_folder指令</p><pre><code>config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;</code></pre><p>synced_folder还有可以配置一些参数，比如type参数配置同步方式。<br>Type可以使用nfs,SMB模式，考虑到跨平台兼容性和，这里虾哥建议使用RSync模式。</p><h2 id="Rsync安装"><a href="#Rsync安装" class="headerlink" title="Rsync安装"></a>Rsync安装</h2><p>rsync 是linux下的一个用于文件同步的协议及相应的实现。</p><p>windows可以安装<a href="https://www.itefix.net/cwrsync?qt-cwrsync=1#qt-cwrsync">cwrsync</a></p><p>安装方法很简单，解压后把bin目录添加到path环境变量即可。</p><h2 id="Vagrantfile写法"><a href="#Vagrantfile写法" class="headerlink" title="Vagrantfile写法"></a>Vagrantfile写法</h2><pre><code>config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;, owner: &quot;root&quot;, group: &quot;root&quot;, type: &quot;rsync&quot;</code></pre><p>这里本地路径，客户机内的共享路径，owner,group都可以根据自己的需要配置。</p><p><img src="/images/vagrant-ansible-persssion-ignore2.png"></p><h2 id="手动同步-自动同步"><a href="#手动同步-自动同步" class="headerlink" title="手动同步&#x2F;自动同步"></a>手动同步&#x2F;自动同步</h2><p>type&#x3D;rsync的文件夹，默认情况下vagrant只会在启动的时候同步一次，之后的修改就不会同步了。</p><p>需要手动同步的话可以运行</p><pre><code>vagrant rsync</code></pre><p>还可以自动实时监听并同步</p><pre><code>vagrant rsync-auto</code></pre><p><img src="/images/vagrant-ansible-persssion-ignore3.png"></p><h2 id="反向同步"><a href="#反向同步" class="headerlink" title="反向同步"></a>反向同步</h2><p>rsync时客户机内的修改无法反映到宿主机的文件夹，即只能实现单向同步，要从客户机向宿主机同步的话可以通过一个插件实现。</p><p>安装插件</p><pre><code>vagrant plugin install vagrant-rsync-back</code></pre><p>手动反向同步</p><pre><code>vagrant rsync-back</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.vagrantup.com/docs/synced-folders/basic_usage">https://www.vagrantup.com/docs/synced-folders/basic_usage</a></li><li><a href="https://linux.die.net/man/1/rsync">https://linux.die.net/man/1/rsync</a></li><li><a href="https://stackoverflow.com/questions/26873316/bidirectional-vagrant-rsync">https://stackoverflow.com/questions/26873316/bidirectional-vagrant-rsync</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
            <tag> vagrant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Vagrant proxyconf快速配置虚拟机代理</title>
      <link href="/2020/11/13/vagrant-proxyconf/"/>
      <url>/2020/11/13/vagrant-proxyconf/</url>
      
        <content type="html"><![CDATA[<p>vagrant 可以通过命令行快速创建和销毁虚拟机，在多项目环境下进行开发工作时可以提高效率。</p><p>但是国内网络连接某些包分发源，例如pip, redhat yum, docker时速度非常慢，在每个虚拟机中都配置一遍又很麻烦，有没有什么好办法能自动配置虚拟机里面的代理呢。</p><p>今天虾哥就带大家了解一下 <a href="https://github.com/tmatilai/vagrant-proxyconf">vagrant-proxyconf</a>这款vagrant插件。</p><h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><p>通过vagrant命令行安装</p><pre><code>vagrant plugin install vagrant-proxyconf</code></pre><h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>插件可以在Vagrantfile中配置代理服务器地址，也可以使用环境变量，由于我在不同环境都用相同的代理，因此就使用环境变量统一配置了。</p><p>环境变量有4个</p><ul><li>VAGRANT_HTTP_PROXY<br>  ：http请求的代理</li><li>VAGRANT_HTTPS_PROXY<br>  : https请求的代理</li><li>VAGRANT_FTP_PROXY<br>  : ftp请求的代理</li><li>VAGRANT_NO_PROXY<br>  : 哪些请求不使用代理</li></ul><p>Windows上配置方法为 在start窗口输入 “编辑系统环境变量” -&gt; “环境变量” -&gt; xx的用户环境变量 -&gt; 新建。输入变量名和变量的值。</p><p>虾哥自己的配置是<br>VAGRANT_HTTP_PROXY&#x3D;<a href="http://10.10.2.40:58591/">http://10.10.2.40:58591</a><br>VAGRANT_HTTPS_PROXY&#x3D;<a href="http://10.10.2.40:58591/">http://10.10.2.40:58591</a><br>VAGRANT_FTP_PROXY&#x3D;socks5:&#x2F;&#x2F;10.10.2.40:51837<br>VAGRANT_NO_PROXY&#x3D;192.168.0.0&#x2F;16,127.0.0.1,10.10.0.0&#x2F;16</p><h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>配置完成后，新创建的vagrant虚拟机就会自动配置http_proxy和https_proxy变量，yum和pip会自动生效。</p><p>对于已经在使用的虚拟机，只需要运行<code>vagrant reload</code>，重启时插件就会自动配置代理，重启完成后就可以正常使用了。</p><h2 id="docker-代理配置"><a href="#docker-代理配置" class="headerlink" title="docker 代理配置"></a>docker 代理配置</h2><p>docker 代理的配置是存储于独立文件的，如果虚拟机启动时还没有安装docker，则不会自动生成docker配置。要在安装docker之后自动配置docker代理配置，需要额外操作。</p><ol><li>安装docker包后，创建docker组，并将root加入docker组 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd docker</span><br><span class="line">usermod -aG docker root </span><br></pre></td></tr></table></figure></li><li>可选,配置docker 自动启动  <code>systemctl --now enable docker</code></li><li>重新启动vagrant，插件自动添加配置</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.docker.com/engine/install/linux-postinstall/">https://docs.docker.com/engine/install/linux-postinstall/</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vagrant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在WindowsTerminal中添加GitBash</title>
      <link href="/2020/11/11/add-git-bash-to-windows-terminal/"/>
      <url>/2020/11/11/add-git-bash-to-windows-terminal/</url>
      
        <content type="html"><![CDATA[<p>Git-bash 是windows上常用的可以使用*nux命令行，随git一起安装，可谓居家旅行必备。</p><p><a href="https://github.com/microsoft/terminal">Windows Terminal</a>是windows 10上的一款开源的多终端窗口，可以在一个窗口中打开不同终端，对于使用终端频繁的同学来说可以节省在多个窗口中来回跳转的不便。</p><p><img src="/images/terminal0.4.png"></p><p>如果能在Windows Terminal中打开Git Bash岂不是所有命令行都能放在一起了。下面虾哥就教你如何配置在Windows Terminal标签栏中开启Bash</p><p>1 打开Windows Terminal<br>2 按下 Ctrl + , 打开程序配置（程序配置是json格式文本文件，会在文本编辑器中打开）<br>3 找到 profiles &gt; list， list下面是个列表，在列表中加入选项，注意json格式，列表最后一项后面没有逗号，下面代码里包含了安装在%USERPROFILE%下的配置，可以根据自身情况修改注释信息。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;00000000-0000-0000-ba54-000000000002&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PROGRAMFILES%/git/usr/bin/bash.exe -i -l&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// &quot;commandline&quot;: &quot;%USERPROFILE%/AppData/Local/Programs/Git/bin/bash.exe -l -i&quot;,</span></span><br><span class="line">    <span class="comment">// &quot;commandline&quot;: &quot;%USERPROFILE%/scoop/apps/git/current/usr/bin/bash.exe -l -i&quot;,</span></span><br><span class="line">    <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%PROGRAMFILES%/Git/mingw64/share/git/git-for-windows.ico&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// &quot;icon&quot;: &quot;%USERPROFILE%/AppData/Local/Programs/Git/mingw64/share/git/git-for-windows.ico&quot;,</span></span><br><span class="line">    <span class="comment">// &quot;icon&quot;: &quot;%USERPROFILE%/apps/git/current/usr/share/git/git-for-windows.ico&quot;,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;startingDirectory&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;%USERPROFILE%&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><img src="/../images/windowsterminalbash.png"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stackoverflow.com/questions/56839307/adding-git-bash-to-the-new-windows-terminal">https://stackoverflow.com/questions/56839307/adding-git-bash-to-the-new-windows-terminal</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Bash </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>便于快速使用的Python Logging脚手架</title>
      <link href="/2020/10/30/python-logging/"/>
      <url>/2020/10/30/python-logging/</url>
      
        <content type="html"><![CDATA[<p>python logging 是一套灵活强大的日志输出框架，具体功能在这里就不赘述了。本文通过gist上的一份共享代码介绍在各种不同使用场景下如何复用一套logging配置入口来高效地使用python logging.</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>原版代码受这位仁兄<a href="https://gist.github.com/kingspp/9451566a5555fb022215ca2b7b802f19">启发</a>， 做了一些改进，修改后的<a href="https://gist.github.com/kevenli/354a3c869e0e4b0b3ba557eb475d56c2">代码</a>。</p><p>源代码分两部分，一部分是python入口，<code>log.py</code>可以放置在脚本文件夹下，也可以放置在包中。</p><pre><code>import osimport yamlimport logging.configimport loggingimport coloredlogsdef setup_logging(default_path=&#39;logging.yaml&#39;, default_level=logging.INFO, env_key=&#39;LOG_CFG&#39;):    &quot;&quot;&quot;    | **@author:** Prathyush SP    | Logging Setup    &quot;&quot;&quot;    path = default_path    value = os.getenv(env_key, None)    if value:        path = value    if os.path.exists(path):        with open(path, &#39;rt&#39;) as f:            try:                config = yaml.safe_load(f.read())                logging.config.dictConfig(config)                coloredlogs.install()            except Exception as e:                print(e)                print(&#39;Error in Logging Configuration. Using default configs&#39;)                logging.basicConfig(level=default_level)                coloredlogs.install(level=default_level)    else:        logging.basicConfig(level=default_level)        coloredlogs.install(level=default_level)        print(&#39;Failed to load configuration file. Using default configs&#39;)</code></pre><p>配置文件可以在部署时按需修改，解耦了日志编写逻辑和日志输出方式。配置文件用yaml格式编写，具有较好的可读性，对编辑也较为友好。默认从当前运行文件夹下加载<code>logging.yaml</code>。注意使用yaml需要安装额外的包pyaml</p><pre><code>version: 1disable_existing_loggers: falseformatters:    standard:        format: &quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;    error:        format: &quot;%(levelname)s &lt;PID %(process)d:%(processName)s&gt; %(name)s.%(funcName)s(): %(message)s&quot;handlers:    console:        class: logging.StreamHandler        level: DEBUG        formatter: standard        stream: ext://sys.stdout    info_file_handler:        class: logging.handlers.RotatingFileHandler        level: INFO        formatter: standard        filename: /tmp/info.log        maxBytes: 10485760 # 10MB        backupCount: 20        encoding: utf8    error_file_handler:        class: logging.handlers.RotatingFileHandler        level: ERROR        formatter: error        filename: /tmp/errors.log        maxBytes: 10485760 # 10MB        backupCount: 20        encoding: utf8    debug_file_handler:        class: logging.handlers.RotatingFileHandler        level: DEBUG        formatter: standard        filename: /tmp/debug.log        maxBytes: 10485760 # 10MB        backupCount: 20        encoding: utf8    critical_file_handler:        class: logging.handlers.RotatingFileHandler        level: CRITICAL        formatter: standard        filename: /tmp/critical.log        maxBytes: 10485760 # 10MB        backupCount: 20        encoding: utf8    warn_file_handler:        class: logging.handlers.RotatingFileHandler        level: WARN        formatter: standard        filename: /tmp/warn.log        maxBytes: 10485760 # 10MB        backupCount: 20        encoding: utf8root:    level: NOTSET    handlers: [console]    propogate: yesloggers:    &lt;module&gt;:        level: INFO        handlers: [console, info_file_handler, error_file_handler, critical_file_handler, debug_file_handler, warn_file_handler]        propogate: no    &lt;module.x&gt;:        level: DEBUG        handlers: [info_file_handler, error_file_handler, critical_file_handler, debug_file_handler, warn_file_handler]        propogate: yes</code></pre><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="disable-existing-loggers"><a href="#disable-existing-loggers" class="headerlink" title="disable_existing_loggers"></a>disable_existing_loggers</h3><p>由于logger在程序包import时就会实例化，可能会早于对logging模块配置的时间，启用此选项可能导致config之前实例的logger没有输出操作。</p><h3 id="propogate"><a href="#propogate" class="headerlink" title="propogate"></a>propogate</h3><p>可以根据需要自行编写logger，python logging logger采用包名完全限定名的全部或部分匹配，如果当前包名没有指定的logger，怎会寻找上一级包名对应的logger。logger配置上有一个propogate参数可以控制logEntry是否继续向下传送到上级包对应的logger，直至root。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>import loggingfrom log import setup_logginglogger = logging.getLogger(__name__)def main():    setup_logging()    logger.info(&#39;hello world&#39;)</code></pre><p>命令行调试</p><pre><code>python -c &quot;from log import setup_logging; setup_logging(); import logging; logger = logging.getLogger(); logger.info(&#39;abc&#39;); logger.error(&#39;error&#39;)&quot; &gt;info.txt 2&gt;err.txt</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.python.org/3/library/logging.config.html#module-logging.config">https://docs.python.org/3/library/logging.config.html#module-logging.config</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何避免误用Singleton模式</title>
      <link href="/2020/05/12/how-to-avoid-misusing-singleton/"/>
      <url>/2020/05/12/how-to-avoid-misusing-singleton/</url>
      
        <content type="html"><![CDATA[<p>Singleton是GoF设计模式之一，其易于理解，实现简单，因此得到广泛使用。但是在OOD<br>面向对象设计领域也有一些批评的声音，说不应该使用singleton模式，甚至有人提出<br>singleton是<a href="https://stackoverflow.com/questions/12755539/why-is-singleton-considered-an-anti-pattern">反模式(anti-pattern)</a>  。<br>虾哥认为技术本身是中性的，没有生来就错的技术(inherently bad)，作为工程师应该<br>有能力掌握技术，知道该在何时何地正确的使用何种技术。</p><p>那么下面就说说singleton的性质，以及如何避免误用singleton模式。</p><h1 id="Singleton的性质"><a href="#Singleton的性质" class="headerlink" title="Singleton的性质"></a>Singleton的性质</h1><p>优势:</p><ol><li>作为静态成员，可以在程序不同位置”便捷地”调用一个共享的对象。</li><li>共享的对象有且只有一个实例。</li><li>共享的对象是一个类的实例，可以使用面向对象方法进行设计，如实现接口。</li></ol><p>劣势:</p><ol><li>Singleton自身既包含行为的实现，又包含其自身的创建，违反了单一职责原则。</li><li>Singleton作为全局对象，可能会隐藏一些依赖关系，如需要按指定顺序访问全局对象的两个<br>对象实际上是有依赖的。</li><li>直接的依赖会构成紧耦合，导致很难进行模拟测试(stub or mock)</li></ol><h1 id="为什么需要使用singleton模式"><a href="#为什么需要使用singleton模式" class="headerlink" title="为什么需要使用singleton模式"></a>为什么需要使用singleton模式</h1><p><img src="https://d3i71xaburhd42.cloudfront.net/6dfb7519c69534a03a72bbfa406c284616aea54c/3-Figure2-1.png"><br><em>插图:面向对象的生命周期树</em></p><p>基于面向对象思想编写的程序，其运行过程中实际上就是各种对象的生命周期不断新陈代谢的过程。<br>每个对象都有负责构建它的另一个对象，因此每个对象实例的生命周期可以看作层次结构，可以表现为树形。</p><p>有的时候我们需要在树的不同位置共享同一个对象实例，用纯面向对象的方式，我们需要找到两个对象的共同祖先，<br>在祖先对象上构造需要共享的对象，并逐层传递到子孙对象上。但是如果层次结构比较深，这种方式就过于繁琐了。<br>想象一下你需要给程序中每个对象都传递一个Logger对象。</p><p><img src="/images/singleton_object_ref.png"><br><em>插图:传递一个对象引用</em></p><p>这种情况下我们可以构造另外一棵树，他的最原始祖先是一个全局变量或者静态成员（即它的生命周期不被其他对象拥有）。<br>这时我们可以方便的从一棵对象生命周期树的不同节点同时访问另一棵树，即可完成对象的共享。</p><p>这种模式在框架设计上非常常见，即提供统一的静态入口点访问某一框架的具体功能，例如log4net中的LogManager对象。</p><h1 id="如何消除或减弱singleton-的不利影响"><a href="#如何消除或减弱singleton-的不利影响" class="headerlink" title="如何消除或减弱singleton 的不利影响"></a>如何消除或减弱singleton 的不利影响</h1><p>我们假设实际的场景中类之间的关系是这样的</p><p><img src="/images/singleton_classdiagram.png"></p><p>这其中有两个依赖关系，即 A类依赖于Singleton类，Singleton类依赖于B类。这种类和类之间的直接依赖违反了dependency inversion原则，造成了紧密的耦合。</p><p>可以使用以下一种或几种方式共用来降低负面影响。</p><h2 id="依赖反转"><a href="#依赖反转" class="headerlink" title="依赖反转"></a>依赖反转</h2><p>A和Singleton之间的关系可以通过依赖反转来解决。</p><p>A类只依赖于ISingleton的约定而非Singleton类的具体实现。</p><p><img src="/images/singleton_a_dependency.png"><br><em>修改前</em></p><p><img src="/images/singleton_a_dependency_after.png"><br><em>修改后</em></p><h2 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入 Dependency Injection"></a>依赖注入 Dependency Injection</h2><p>让使用者(client)被注入一个其依赖的对象的实例(service)，而不是让它自行构建或获取service的实例。</p><pre><code>public class A&#123;    private ISingleton singleton;    public A(ISingleton singleton)    &#123;        this.singleton = singleton;    &#125;    public void Foo()    &#123;        this.singleton.Bar()    &#125;&#125;</code></pre><h2 id="不变对象-Immutable"><a href="#不变对象-Immutable" class="headerlink" title="不变对象  Immutable"></a>不变对象  Immutable</h2><p>如果全局对象的写入和读取在顺序上有隐含条件，则该读取操作和写入操作实际上是有依赖关系的。<br>更糟糕的是这种依赖关系没有暴露出来造成不易察觉的设计问题。</p><p><code>提供一个显式或隐式的初始化过程，在其生命周期中保持状态不会变化</code>，确保总是有<br>可预期的调用，以便支持单元测试。</p><p>隐式初始化应从一个指定位置，如环境变量，某个(或多个)具体的配置文件路径，加载构造内部对象所需的信息。<br>则单元测试时可以通过间接的方式修改构造过程注入所需的mock对象。</p><p><img src="/images/singleton_strategy.png"></p><p>参见log4net config<br><a href="https://logging.apache.org/log4net/release/manual/configuration.html">https://logging.apache.org/log4net/release/manual/configuration.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="">https://en.wikipedia.org/wiki/Dependency_inversion_principle</a><br><a href="">https://en.wikipedia.org/wiki/Dependency_injection</a><br><a href="">https://fuzhe1989.github.io/2017/09/30/why-global-static-singleton-var-evil/</a><br><a href="">https://www.dre.vanderbilt.edu/~schmidt&#x2F;PDF&#x2F;Context-Object-Pattern.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Singleton </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给Django应用增加一个初始化admin管理员用户的命令行工具</title>
      <link href="/2020/04/20/django-commandline-init-admin-account/"/>
      <url>/2020/04/20/django-commandline-init-admin-account/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要添加一个初始化超级用户的命令行入口"><a href="#为什么要添加一个初始化超级用户的命令行入口" class="headerlink" title="为什么要添加一个初始化超级用户的命令行入口"></a>为什么要添加一个初始化超级用户的命令行入口</h1><p>django提供了一系列重要而且好用的命令行工具，使用创建项目时自动生成的manage.py，<br>或者全局django-admin都可以运行这些程序。</p><pre><code>python mamage.pydjango-admin</code></pre><p>其中在启用了<code>django.contrib.auth</code>app之后，我们可以受用createsuperuser命令来创建超级用户。</p><pre><code>python manage.py createsuperuser</code></pre><p>这个命令通常时我们启用django身份验证功能之后要登录到admin站点必须要使用的命令。但是这个命令的<br>问题在于它只能用交互方式运行，我们无法用一个非交互式脚本来创建用户，比如我们的站点需要一键<br>安装、自动化搭建测试环境等等场景。</p><p>在使用命令行之外我们也有其他选项，比如在migrations增加一个创建默认超级用户的脚本，在安装过程中<br>执行migrate从而添加默认超级用户。但这样做的问题是默认用户信息在所有环境中都是相同的，如果管理人员<br>忘记修改默认密码，可能会导致安全风险。</p><p>如果有一个命令行能用无交互的方式，使用参数来指定超级用户的账号和密码，就会适应更多场景的要求。</p><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><h2 id="命令行接口的设计"><a href="#命令行接口的设计" class="headerlink" title="命令行接口的设计"></a>命令行接口的设计</h2><p>我们需要一个命令行工具，用如下的方式创建一个超级用户。</p><pre><code>python manage.py initadmin --user=admin --password=YourPassword --email=abc@example.com</code></pre><p>这个命令行还能从环境变量中读取参数信息</p><pre><code>DJANGO_SU_NAME=admin DJANGO_SU_PASSWORD=YourPassword DJANGO_SU_EMAIL=abc@example.com python manage.py initadmin 或者export DJANGO_SU_NAME=adminexport DJANGO_SU_PASSWORD=YourPasswordexport DJANGO_SU_EMAIL=abc@example.compython manage.py initadmin </code></pre><h2 id="使用django-custom-django-admin-commands框架"><a href="#使用django-custom-django-admin-commands框架" class="headerlink" title="使用django custom django-admin commands框架"></a>使用django custom django-admin commands框架</h2><p>django提供了自行扩展命令行工具的框架，添加相关代码后可以直接采用manage.py或python-admin命令行进行调用。<br>相关文档可以参考!()[<a href="https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/]">https://docs.djangoproject.com/en/3.0/howto/custom-management-commands/]</a></p><p>首先需要在自己的app中创建指定文件夹，django会从指定文件夹中加载相应模块，假设你的app名字为myapp，<br>command模块应在<code>myapp/management/commands</code>文件夹下，<br>这两个文件夹都是package，因此别忘了在<code>management</code>文件夹和<code>commands</code>文件夹都添加<code>__init__.py</code>文件，</p><p>在<code>commands</code> 包下添加<code>initadmin</code>模块，即<code>initadmin.py</code></p><pre><code># myapp/management/commands/initadmin.pyimport osfrom django.core.management.base import BaseCommandfrom django.contrib.auth.models import Userclass Command(BaseCommand):    def add_arguments(self, parser):        parser.add_argument(&#39;--user&#39;)        parser.add_argument(&#39;--password&#39;)        parser.add_argument(&#39;--email&#39;)    def handle(self, *args, **options):        admin_username = options.get(&#39;user&#39;) or os.environ.get(&#39;DJANGO_SU_NAME&#39;)        admin_email = options.get(&#39;email&#39;) or os.environ.get(&#39;DJANGO_SU_EMAIL&#39;)        admin_password = options.get(&#39;password&#39;) or os.environ.get(&#39;DJANGO_SU_PASSWORD&#39;)        if not admin_username:            raise Exception(&quot;No username specified.&quot;)        if not admin_email:            raise Exception(&#39;No email specified.&#39;)        if not admin_password:            raise Exception(&#39;No password specified.&#39;)        if User.objects.filter(username=admin_username).first():            print(f&#39;&#123;admin_username&#125; user already exists.&#39;)            return        admin_user = User.objects.create_superuser(username=admin_username,                                                   email=admin_email,                                                   password=admin_password)        admin_user.is_active = True        admin_user.is_admin = True        admin_user.save()        print(f&#39;&#123;admin_username&#125; user created.&#39;)</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="命令行使用"><a href="#命令行使用" class="headerlink" title="命令行使用"></a>命令行使用</h2><p>如前面提到的方式使用即可，可通过命令行参数指定admin用户信息，或者使用环境变量</p><pre><code>DJANGO_SU_NAME=admin DJANGO_SU_PASSWORD=YourPassword DJANGO_SU_EMAIL=abc@example.com python manage.py initadmin DJANGO_SU_NAME=admin DJANGO_SU_PASSWORD=YourPassword DJANGO_SU_EMAIL=abc@example.com python manage.py initadmin </code></pre><h2 id="在docker中使用"><a href="#在docker中使用" class="headerlink" title="在docker中使用"></a>在docker中使用</h2><p>首先在entrypoint.sh 中增加检查选项，并根据选项运行命令行</p><pre><code># docker-entrypoint.shif [ &quot;x$DJANGO_MANAGEPY_INITADMIN&quot; = &#39;xon&#39; ]; then  $PYTHON manage.py initadminfi</code></pre><p>在docker运行时指定参数</p><pre><code>docker run -e DJANGO_MANAGEPY_INITADMIN=on -e DJANGO_SU_NAME=admin -e DJANGO_SU_PASSWORD=YourPassword xxx</code></pre><p>或者在docker-compose中指定参数</p><pre><code>#docker-compose.ymlversion: &#39;3&#39;services:  web:    image: xxx    ports:      - &quot;8000:8000&quot;    environment:      DJANGO_MANAGEPY_INITADMIN: &#39;on&#39;      DJANGO_SU_NAME: &#39;admin&#39;      DJANGO_SU_PASSWORD: &#39;YourPassword&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> django, docker, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx默认站点生成空SSL证书</title>
      <link href="/2020/04/16/self-signed-ssl-key-for-default-server/"/>
      <url>/2020/04/16/self-signed-ssl-key-for-default-server/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用默认站点空证书"><a href="#为什么要使用默认站点空证书" class="headerlink" title="为什么要使用默认站点空证书"></a>为什么要使用默认站点空证书</h2><p>开启HTTPS通信可以有效防范中间人攻击，是当前web安全的最佳实践之一。但是在默认情况下<br>通过IP直接访问443(HTTPS默认端口)，nginx会认为是在访问第一个已配置的ssl server，将<br>请求发送至web节点，并在TLS通讯握手过程中返回该节点对应的证书信息。</p><p>这种默认行为会带来以下安全威胁：</p><h3 id="服务器响应随意的攻击扫描请求"><a href="#服务器响应随意的攻击扫描请求" class="headerlink" title="服务器响应随意的攻击扫描请求"></a>服务器响应随意的攻击扫描请求</h3><p>在公网上充斥各各种扫描攻击程序，他们会大范围的扫描IP和常用端口，对服务器发送无差别的请求。<br>处理这些请求可能导致额外的安全风险，以及额外的资源损耗。</p><h3 id="泄露隐藏于站点防护之后的源站点信息"><a href="#泄露隐藏于站点防护之后的源站点信息" class="headerlink" title="泄露隐藏于站点防护之后的源站点信息"></a>泄露隐藏于站点防护之后的源站点信息</h3><p>有时为了防御来自互联网的流量攻击，如DDos攻击，我们会把源站点部署在防御节点之后，即用户请求<br>先发送到防御服务器，web服务器处理由防御服务器转发来的请求。</p><p>这种情况下web服务器不应该直接处理任何流量，也不应该由用户直接访问。处于运维调试等目的，我们<br>仍然希望https端口可以访问，同时web服务器可以根据某些规则处理请求以便维护人员可以检查服务状态。<br>此时源站点信息应该是对外保密的，但如果证书信息泄露，可能导致攻击者绕过防御节点直接访问源站点，<br>造成损失。</p><h2 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h2><p>通过制定nginx在处理没有制定域名(host)的请求直接返回默认http消息，可以避免信息泄露。</p><p>在http端口上的配置如下:</p><pre><code>server &#123;    listen       80  default_server;    server_name  _;    return       444;&#125;</code></pre><p>指定<code>server_name</code>为空<code>_</code>可以指定处理所有未匹配的server_name匹配规则的请求。<a href="http://nginx.org/en/docs/http/server_names.html">http://nginx.org/en/docs/http/server_names.html</a></p><p>配置SSL端口也是相同的思路，但是SSL配置必须指定SSL证书私钥，因此我们需要生成一个本地的证书，<br>不带有任何站点信息。</p><pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/conf.d/nginx.key -out /etc/nginx/conf.d/nginx.crt</code></pre><p>运行后需要命令行交互输入一些参数，一直Enter使用默认值即可。生成的公钥证书为<code>nginx.crt</code>，私钥证书为<code>nginx.key</code></p><p>按需要将证书文件复制到nginx需要访问的位置。然后配置nginx ssl站点。</p><pre><code>server &#123;    listen              443 ssl default_server;    server_name         _;    ssl_certificate     /etc/nginx/conf.d/nginx.crt;    ssl_certificate_key /etc/nginx/conf.d/nginx.key;    return              444;&#125;</code></pre><p>可以将以上默认站点http端口和https端口配置在同一个文件中，如<code>/etc/nginx/conf.d/default.conf</code></p><pre><code>server &#123;    listen              80  default_server;    server_name         _;    return              444;&#125;server &#123;    listen              443 ssl default_server;    server_name         _;    ssl_certificate     /etc/nginx/conf.d/nginx.crt;    ssl_certificate_key /etc/nginx/conf.d/nginx.key;    return              444;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx, SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notepad++ 插件管理器安装</title>
      <link href="/2020/03/10/npp-plugin-manager-install/"/>
      <url>/2020/03/10/npp-plugin-manager-install/</url>
      
        <content type="html"><![CDATA[<p>新版本的NPP不再包含插件管理器，需要的话需要自行安装。</p><p><img src="/images/npp_no_plugin_manager.png"></p><h1 id="安装方法1"><a href="#安装方法1" class="headerlink" title="安装方法1"></a>安装方法1</h1><p>download and install version 7.3.3:</p><p><a href="https://notepad-plus-plus.org/download/v7.3.3.html">https://notepad-plus-plus.org/download/v7.3.3.html</a></p><p>and then download and upgrade it with the latest version:</p><p><a href="https://notepad-plus-plus.org/download/v7.5.1.html">https://notepad-plus-plus.org/download/v7.5.1.html</a></p><h1 id="安装方法2"><a href="#安装方法2" class="headerlink" title="安装方法2"></a>安装方法2</h1><p>手动下载插件二进制包</p><p><a href="https://github.com/bruderstein/nppPluginManager/releases">https://github.com/bruderstein/nppPluginManager/releases</a></p><p>uni &#x3D; 32位版本 , x64 &#x3D; 64位</p><p>解压到notepad++程序文件夹，重启程序即可。</p><p><img src="/images/npp_plugin_installed.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Notepad++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos运行Docker出错RuntimeError</title>
      <link href="/2020/03/08/docker-runtime-error-on-centos7/"/>
      <url>/2020/03/08/docker-runtime-error-on-centos7/</url>
      
        <content type="html"><![CDATA[<h1 id="出错信息"><a href="#出错信息" class="headerlink" title="出错信息"></a>出错信息</h1><p>在一台新装的Centos7虚拟机上运行Docker，提示错误</p><pre><code>ERROR: for hello_world  Cannot start service hello_world: oci runtime error: container_linux.go:235: starting container process caused &quot;process_linux.go:258: applying cgroup configuration for process caused \&quot;Cannot set property TasksAccounting, or unknown property.\&quot;&quot;</code></pre><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>原因是centos系统版本落后，通过yum更新后重启即可</p><pre><code>yum update -yshutdown -r</code></pre>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何从Google Play下载APK</title>
      <link href="/2020/02/23/download-apk-from-google-play/"/>
      <url>/2020/02/23/download-apk-from-google-play/</url>
      
        <content type="html"><![CDATA[<p>Google Play是Android官方应用商店，App非常齐全，但是由于某些不可抗力的原因，<br>我们的手机不能直接使用。</p><p>下面介绍一种方法，在PC上可以从Google Play直接下载APK。本方法需要科学上网。</p><h2 id="1-安装浏览器插件"><a href="#1-安装浏览器插件" class="headerlink" title="1. 安装浏览器插件"></a>1. 安装浏览器插件</h2><p>插件名：Play Store APK Downloader</p><p>Chrome和Firefox上都有同名插件。</p><p><img src="/images/google_play_install_addones.png" title="Install AddOns"></p><h2 id="2-在GooglePlay打开要下载的APP页面"><a href="#2-在GooglePlay打开要下载的APP页面" class="headerlink" title="2. 在GooglePlay打开要下载的APP页面"></a>2. 在GooglePlay打开要下载的APP页面</h2><p>在Google Play中搜索APP并打开APP首页，此时插件图标会提示数字1，点击插件图标即可打开下载页面<br><img src="/images/google_play_open_app_page.png" title="Open App Page"></p><h2 id="3-在下载页面下载"><a href="#3-在下载页面下载" class="headerlink" title="3. 在下载页面下载"></a>3. 在下载页面下载</h2><p>下载页面在一个网站里面，需要在页面上点击下载，即可下载。</p><p><img src="/images/google_play_download.png" title="Download"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Google Play </tag>
            
            <tag> APK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker容器设置时区</title>
      <link href="/2019/09/08/docker-container-timezone/"/>
      <url>/2019/09/08/docker-container-timezone/</url>
      
        <content type="html"><![CDATA[<p>我们在使用一些公共镜像的时候，往往不操作build过程，跟自行维护的服务器设置时区还是有所区别的。<br>那么我们如何既能使用到公共镜像的便利，又能根据自己的需要设置容器的时区呢，下面就介绍相关的方法。</p><h1 id="1-使用Date命令"><a href="#1-使用Date命令" class="headerlink" title="1 使用Date命令"></a>1 使用Date命令</h1><p>最简单的修改容器时间的方法是在创建容器后使用date命令</p><pre><code>docker exec -it container-name /bin/bash date +%T -s &quot;10:00:00&quot;</code></pre><p>时区的变化一般会立即反映出来，但有些时候必须要重启才能生效。</p><h1 id="2-使用环境变量"><a href="#2-使用环境变量" class="headerlink" title="2 使用环境变量"></a>2 使用环境变量</h1><p>通过设置环境变量也可以设置容器的时区信息</p><pre><code>docker run -e TZ=Asia/Shanghai ubuntu date</code></pre><p>相应的在docker-compose下</p><pre><code>environment:  - TZ=Asia/Shanghai</code></pre><p>需要安装时区数据包<code>tzdata</code>才能使用环境变量设置。通过设置NTP服务器，我们可以确保容器里的时区已经同步。</p><h1 id="3-使用-Dockerfile"><a href="#3-使用-Dockerfile" class="headerlink" title="3 使用 Dockerfile"></a>3 使用 Dockerfile</h1><p>在主机环境中，或者需要非常多相同容器要运行的时候，最简单的方法是使用Dockerfile。</p><p>Dockerfile包含了每个容器最基本的配置信息，要修改Docker容器的时区，我们可以修改相应的Dockerfile.</p><p>这些配置信息在容器被重新创建(recreate)时会被反映出来，而且这些在Dockerfile中运行的命令会在root用户下运行。</p><p>比如：</p><pre><code>RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezoneRUN apk add tzdata</code></pre><p>安装tzdata包的方式在大部分linux系统下都相同。</p><p>我们也可以在entrypoint入口点脚本中包含设置时区的指令，这可以确保无论何时容器重新启动时时区设置都生效。</p><h1 id="4-使用volumes卷"><a href="#4-使用volumes卷" class="headerlink" title="4 使用volumes卷"></a>4 使用volumes卷</h1><p>使用Docker容器的最大的问题就是在重新启动时，保存的容器中的数据不会被持久化。为了解决这种问题，我们使用<br>Docker data volumes卷。</p><p>数据卷Data volumes可以在docker服务器共享，并且包含容器里面的特定数据。在卷中的数据可以被持久化而不会在<br>容器重新创建时丢失。</p><p>Docker中的文件夹 <code>/usr/share/zoneinfo</code> 包含可以使用的时区信息，把想要的时区信息从这个文件夹拷贝到<br><code>/etc/localtime</code>文件就可以设置时区。</p><p>我们可以在服务器上设置好时区，然后把这个时区文件通过volume共享到容器里面</p><pre><code>volumes:- &quot;/etc/timezone:/etc/timezone:ro&quot;- &quot;/etc/localtime:/etc/localtime:ro&quot;</code></pre><p>这样通过在docker-compose中设置的时区信息就会跟服务器达成一致了。</p><h1 id="5-使用镜像"><a href="#5-使用镜像" class="headerlink" title="5 使用镜像"></a>5 使用镜像</h1><p>有时候在容器数量太大的时候，手动修改时区并不可行，要创建更多相同时区设置的实例的时候，我们可以使用镜像Images。</p><p>在给一个容器设置好时区后，退出这个容器，然后用<code>docker commit</code>从这个容器创建一个新镜像。NTP服务器配置<br>也可以在镜像里配置好。</p><pre><code>docker commit container-name image-name</code></pre><p>使用这个镜像，我们就可以创建很多个基于相同时区的容器了，可以保存这个镜像已备将来使用。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Windows 10上同时运行Python2和Python3</title>
      <link href="/2019/08/17/install-both-python2-and3-on-win10/"/>
      <url>/2019/08/17/install-both-python2-and3-on-win10/</url>
      
        <content type="html"><![CDATA[<p>编写python程序难免需要同时用到python2和python3两种环境，那么怎么才能在windows 10上同时安装两种环境呢</p><h1 id="1-安装python2-7"><a href="#1-安装python2-7" class="headerlink" title="1 安装python2.7"></a>1 安装python2.7</h1><h2 id="1-1-在官方网站下载python2-7"><a href="#1-1-在官方网站下载python2-7" class="headerlink" title="1.1 在官方网站下载python2.7"></a>1.1 在官方网站下载python2.7</h2><p><a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p><p><img src="/images/install_python.png"></p><h2 id="1-2-运行安装程序"><a href="#1-2-运行安装程序" class="headerlink" title="1.2 运行安装程序"></a>1.2 运行安装程序</h2><p><img src="/images/install_python_27.png"></p><p><img src="/images/install_python_27_2.png"><br>注意选择把python添加到path环境变量</p><p><img src="/images/install_python_27_3.png"></p><h1 id="2-安装python3-7"><a href="#2-安装python3-7" class="headerlink" title="2 安装python3.7"></a>2 安装python3.7</h1><h2 id="2-1-在官方网站下载python3-7"><a href="#2-1-在官方网站下载python3-7" class="headerlink" title="2.1 在官方网站下载python3.7"></a>2.1 在官方网站下载python3.7</h2><p><a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p><p><img src="/images/install_python.png"></p><h2 id="2-2-运行安装程序"><a href="#2-2-运行安装程序" class="headerlink" title="2.2 运行安装程序"></a>2.2 运行安装程序</h2><p><img src="/images/install_python_3.png"><br>选择自定义安装</p><p><img src="/images/install_python_3_1.png"><br>安装选项里勾上pip</p><p><img src="/images/install_python_3_2.png"><br>路径改为 c:\Python37，选择将路径添加到path环境变量</p><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h1><p>右键点左下角win图标-系统- 弹出窗口里点击“系统信息” - “高级系统设置” - “环境变量”</p><p><img src="/images/install_python_path.png"></p><p>在环境变量中确认python2和python3路径都存在。</p><p><img src="/images/install_python_2.png"></p><p>默认情况下python2和python3的运行程序都是python.exe，所以才出现难以共存的问题，<br>我们可以找到python2运行目录，把python.exe改名为python2.exe</p><p><img src="/images/install_python_4.png"></p><p>但是此时会发现python2可以运行了，但是pip2运行不了。</p><p><img src="/images/install_python_5.png"><br><img src="/images/install_python_6.png"></p><p>卸载pip2 </p><pre><code>python2 -m pip uninstall pip</code></pre><p>下载<a href="https://bootstrap.pypa.io/get-pip.py">get-pip.py</a></p><pre><code>python2 get-pip.py</code></pre><p>这样就可以了</p><p><img src="/images/install_python_7.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows, Python, Python2, Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样在Centos7上安装SQL-python</title>
      <link href="/2019/08/16/install-python-mysql-on-centos7/"/>
      <url>/2019/08/16/install-python-mysql-on-centos7/</url>
      
        <content type="html"><![CDATA[<p>以前要在服务器上安装python访问mysql的库是相当麻烦，既要安装mysql-devel开发包，还要安装python源码。</p><p>那么如何在在Centos7上安装MySQL-python库呢。</p><h1 id="1-yum-安装"><a href="#1-yum-安装" class="headerlink" title="1 yum 安装"></a>1 yum 安装</h1><pre><code>sudo yum install MySQL-python</code></pre><p><img src="/images/install_mysql_python_on_centos7.jpg"></p><p>再也不需要安装一大堆东西了。完成。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7, Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由于找不到 MSVCR120.dll，无法继续执行代码。重新安装程序可能会解决此问题。</title>
      <link href="/2019/08/14/miss_msvcr120dll/"/>
      <url>/2019/08/14/miss_msvcr120dll/</url>
      
        <content type="html"><![CDATA[<p>运行程序时出现以下错误<br><img src="/images/miss_msvcr120_dll.png"></p><pre><code>由于找不到 MSVCR120.dll，无法继续执行代码。重新安装程序可能会解决此问题。</code></pre><p>需要vc2013分发包，在以下地址下载</p><p><a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=40784">https://www.microsoft.com/zh-CN/download/details.aspx?id=40784</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Docker快速部署Nginx反代，以及ACME自动续证书</title>
      <link href="/2019/08/07/nginx-acme-docker/"/>
      <url>/2019/08/07/nginx-acme-docker/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Nginx反向代理速度快，可以自定义各种转发规则，可以说是站长的好朋友。</p><p><a href="https://github.com/Neilpang/acme.sh">acme.sh</a>支持多个域名服务商的证书生成，让站长免费获取到ssl带来的安全性，也是不可或缺的好伙伴。</p><p>本文虾哥将本着DRY原则，让站长不需要记住部署nginx和acme的若干命令，快速搭建起安全实用的ssl反向代理服务器。</p><h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><p>使用docker部署程序省去安装各种语言运行环境的麻烦，但docker本身还是需要准备一下。</p><p>下面介绍在centos7系统下安装docker 和 docker-compose的步骤。其他系统可以自行查找相关文档。</p><p>##1.1 安装docker</p><pre><code>sudo yum install docker -y</code></pre><p>安装完成后启动docker</p><pre><code>sudo systemctl start dockersudo systemctl enable docker</code></pre><p>##1.2安装docker-compose</p><p>docker-compose是python包，通过docker-compose，docker运行镜像的各种配置可以直接写入文件，重启和修改都非常容易。</p><pre><code># 通过yum安装pip官方没有直接提供rpm包，可以通过epel-release库安装sudo yum install epel-releasesudo yum isntall python2-pipsudo pip isntall docker-compose</code></pre><p>这样就安装完成了，运行docker-compose命令行</p><pre><code>docker-compose --help</code></pre><h2 id="1-3-准备程序运行目录"><a href="#1-3-准备程序运行目录" class="headerlink" title="1.3 准备程序运行目录"></a>1.3 准备程序运行目录</h2><p>在决定运行docker-compose的任意路径创建好目录，以后我们程序运行相关的文件都保存在该路径下，如&#x2F;app</p><pre><code>mkdir /appcd /app</code></pre><p>在运行目录下创建nginx</p><h1 id="2-acme-sh-申请证书并定期更新"><a href="#2-acme-sh-申请证书并定期更新" class="headerlink" title="2. acme.sh 申请证书并定期更新"></a>2. acme.sh 申请证书并定期更新</h1><h1 id="2-1-acme-sh-申请证书"><a href="#2-1-acme-sh-申请证书" class="headerlink" title="2.1 acme.sh 申请证书"></a>2.1 acme.sh 申请证书</h1><p>在程序运行路径下创建docker-compose.yml，通过docker-compose启动docker镜像的所有参数信息都会写入到该文件中</p><pre><code># /app/docker-compose.ymlversion: &#39;3&#39;services:    acme.sh:        image: neilpang/acme.sh        volumes:            - &quot;./acme.sh:/acme.sh:z&quot;        environment:            - CF_Key=&quot;xxx&quot;            - CF_Email=&quot;yyy&quot;        command: daemon</code></pre><p>本文以cloudflare申请证书为例，其他域名服务商可以根据要求将相关的身份信息写入environment环境变量</p><p>运行acme生成证书</p><pre><code>sudo docker-compose run acme.sh --issue --dns dns_cf -d xxx.example.com</code></pre><p>域名和dns服务商参数根据实际情况自行修改。要使用cloudflare创建证书，需要把域名的ns指向到cloudflare并在cloudflare网站上申请管理员的key。运行完成后证书会保存在.acme.sh&#x2F;xxx.example.com&#x2F;文件夹下。</p><h2 id="2-2-自动更新证书"><a href="#2-2-自动更新证书" class="headerlink" title="2.2 自动更新证书"></a>2.2 自动更新证书</h2><p>这样免费申请的证书只有3个月的有效期，通过command: daemon参数运行后，该进程会定期自动去域名服务商更新证书，再也不用为证书过期苦恼了。</p><pre><code>docker-compose up -d</code></pre><h1 id="2-Nginx"><a href="#2-Nginx" class="headerlink" title="2. Nginx"></a>2. Nginx</h1><p>Nginx提供了<a href="https://hub.docker.com/_/nginx/">官方镜像</a><br>直接使用官方镜像就可以启动nginx服务。但要想根据我们的要求运行反向代理，还得编写一个配置文件。</p><p>创建&#x2F;app&#x2F;nginx&#x2F;conf文件夹</p><pre><code>mkdir -p /app/nginx/conf</code></pre><p>在该文件夹下创建proxy.conf文件</p><pre><code># /app/nginx/conf/proxy.confserver &#123;    listen 80;    server_name   xxx.example.com;    return 301 https://$host;&#125;server &#123;    listen 443 ssl;    server_name             xxx.example.com;    ssl_certificate         /etc/nginx/certs/$server_name/fullchain.cer;    ssl_certificate_key     /etc/nginx/certs/$server_name/$server_name.key;    add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot; always;    location / &#123;        proxy_pass http://realserver;        proxy_set_header X-Real-IP $remote_addr;        proxy_http_version      1.1;        proxy_cache_bypass      $http_upgrade;        proxy_set_header Upgrade                $http_upgrade;        proxy_set_header Connection             &quot;upgrade&quot;;        proxy_set_header Host                   $host;        proxy_set_header X-Forwarded-For        $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto      $scheme;        proxy_set_header X-Forwarded-Host       $host;        proxy_set_header X-Forwarded-Port       $server_port;    &#125;&#125;</code></pre><p>这个配置启动了HSTS，强制使用https，增强了web服务的安全性。</p><p>把xxx.example.com替换成实际的域名。 realserver是反代对应的真实服务器地址。</p><p>要禁用直接用ip地址访问可以增加一个server节：</p><pre><code>server &#123;    listen 80 default_server;    return 444;&#125;</code></pre><p>nginx在docker-compose中配置如下：</p><pre><code>nginx:    image: nginx    ports:        - &quot;80:80&quot;        - &quot;443:443&quot;    volumes:        - &quot;./acme.sh:/etc/nginx/certs&quot;        - &quot;./nginx/conf:/etc/nginx/conf.d:z&quot;        - &quot;./nginx/log/:/var/log/nginx/:z&quot;    environment:        - ENV=production</code></pre><p>通过docker-compose启动一组容器</p><pre><code>docker-compose up -d</code></pre><p>大功告成。</p><p>最后完整版的docker-compose文件如下：</p><pre><code># /app/docker-compose.ymlversion: &#39;3&#39;services:    acme.sh:        image: neilpang/acme.sh        volumes:            - &quot;./acme.sh:/acme.sh:z&quot;        environment:            - CF_Key=&quot;xxx&quot;            - CF_Email=&quot;yyy&quot;        command: daemon    nginx:        image: nginx        network_mode: host        ports:            - &quot;80:80&quot;            - &quot;443:443&quot;        volumes:            - &quot;./acme.sh:/etc/nginx/certs&quot;            - &quot;./nginx/conf:/etc/nginx/conf.d:z&quot;            - &quot;./nginx/log/:/var/log/nginx/:z&quot;        environment:            - ENV=production</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker, acme.sh, nginx, https, SSL证书, SSL证书自动续期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎样获得hostloc邀请码</title>
      <link href="/2019/07/11/how-to-register-hostloc/"/>
      <url>/2019/07/11/how-to-register-hostloc/</url>
      
        <content type="html"><![CDATA[<p>Hostloc是先进最火热的VPS和站长论坛，大家在上面分享建站经验和建站资源，是非常棒的站长交流平台。</p><p>但是很多人发现网站需要邀请码才能注册，那么怎么获得邀请码呢？</p><p>可以直接在某宝购买，在某宝上搜索hostloc邀请码，1-2元一枚，在线购买直接发货就可以注册了</p><p>hostloc发帖，回帖，访问其他人的主页（仅限PC版面）均可以获得积分，越活跃升级越快。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python_setup.py_develop_failed</title>
      <link href="/2019/07/09/python-setup-py-develop-failed/"/>
      <url>/2019/07/09/python-setup-py-develop-failed/</url>
      
        <content type="html"><![CDATA[<p>在开发python包时经常需要用到python setup.py develop将当前路径动态注册到python,<br>以后每次修改都不需要重新安装就可以在全局引用包。</p><p>但是最近发现在运行python setup.py develop时报错，显示</p><pre><code>Traceback (most recent call last):  File &quot;setup.py&quot;, line 38, in &lt;module&gt;    &#39;attrs&gt;=17.4.0&#39;  File &quot;/usr/lib64/python2.7/distutils/core.py&quot;, line 152, in setup    dist.run_commands()  File &quot;/usr/lib64/python2.7/distutils/dist.py&quot;, line 953, in run_commands    self.run_command(cmd)  File &quot;/usr/lib64/python2.7/distutils/dist.py&quot;, line 972, in run_command    cmd_obj.run()  File &quot;/usr/lib/python2.7/site-packages/setuptools/command/develop.py&quot;, line 27, in run    self.install_for_development()  File &quot;/usr/lib/python2.7/site-packages/setuptools/command/develop.py&quot;, line 129, in install_for_development    self.process_distribution(None, self.dist, not self.no_deps)  File &quot;/usr/lib/python2.7/site-packages/setuptools/command/easy_install.py&quot;, line 701, in process_distribution    distreq.project_name, distreq.specs, requirement.extrasTypeError: __init__() takes exactly 2 arguments (4 given)</code></pre><p>原因是python默认安装了旧版本的setuptools，pip安装时不会删除默认版本，导致site-packages下面有多个版本</p><pre><code> ll /lib/python2.7/site-packages | grep setuptoolsdrwxr-xr-x.  6 root root   4096 Jul  8 11:43 setuptoolsdrwxr-xr-x.  2 root root    179 Jul  8 11:43 setuptools-0.9.8-py2.7.egg-infodrwxr-xr-x.  2 root root    170 Jul  8 11:33 setuptools-41.0.1.dist-info-rw-r--r--.  1 root root     33 Jul  8 11:33 setuptools.pth</code></pre><p>解决方法是多次运行pip uninstall删除所有版本，再重新安装</p><pre><code>pip uninstall setuptoolspip uninstall setuptoolspip install setuptools</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>怎样在Cento7上安装Twisted</title>
      <link href="/2019/07/04/install-twisted-on-centos7/"/>
      <url>/2019/07/04/install-twisted-on-centos7/</url>
      
        <content type="html"><![CDATA[<p>scrapy项目依赖twisted，但是在centos7上直接用pip install twisted可能会安装失败。本文介绍如何在Centos7上顺利安装Twisted</p><h2 id="step1-安装epel-release包"><a href="#step1-安装epel-release包" class="headerlink" title="step1 安装epel-release包"></a>step1 安装epel-release包</h2><p>Centos7官方repository中没有包含python相关的包，幸运的是epel-release包含了python2相关的包。</p><pre><code>yum install -y epel-release</code></pre><h2 id="step2-安装twisted依赖包"><a href="#step2-安装twisted依赖包" class="headerlink" title="step2 安装twisted依赖包"></a>step2 安装twisted依赖包</h2><p>Twisted有C扩展，默认需要python-devel和GCC，可以通过yum安装</p><pre><code>yum install -y python-pip python-devel gcc</code></pre><h2 id="step3-安装twisted"><a href="#step3-安装twisted" class="headerlink" title="step3 安装twisted"></a>step3 安装twisted</h2><pre><code>pip install twisted</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>怎样在Centos7上安装Python3.6</title>
      <link href="/2019/07/02/how-to-install-python3-on-centos7/"/>
      <url>/2019/07/02/how-to-install-python3-on-centos7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装ius源"><a href="#1-安装ius源" class="headerlink" title="1.安装ius源"></a>1.安装ius源</h2><p><a href="https://ius.io/">ius</a>是一个专门提供经过验证RPM包的第三方社区，很多官方RPM库没有提供的新功能可以在该网站上找到。</p><pre><code>sudo yum install -y https://centos7.iuscommunity.org/ius-release.rpm</code></pre><h2 id="2-更新YUM"><a href="#2-更新YUM" class="headerlink" title="2.更新YUM"></a>2.更新YUM</h2><pre><code>sudo yum update</code></pre><h2 id="3-安装python3包"><a href="#3-安装python3包" class="headerlink" title="3.安装python3包"></a>3.安装python3包</h2><pre><code>sudo yum install -y python36u python36u-libs python36u-devel python36u-pip</code></pre><p>然后就可以尽情使用python3了</p><pre><code>python3.6 -V# Python 3.6.8pip3 -V# pip 9.0.1 from /usr/lib/python3.6/site-packages (python 3.6)</code></pre><p>添加软链接</p><pre><code>ln -s /usr/bin/python3.6 /usr/bin/python3ln -s /usr/bin/pip3.6 /usr/bin/pip3</code></pre><p>现在可以直接使用python3和pip3命令了    </p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在windows上安装twisted</title>
      <link href="/2019/07/01/install-twisted-on-windows/"/>
      <url>/2019/07/01/install-twisted-on-windows/</url>
      
        <content type="html"><![CDATA[<p>Twisted库是比较流行的一个异步操作库，实现了大量的网络协议，scrapy就是基于Twisted实现异步操作和网络通讯。文末有彩蛋。</p><h2 id="方法1-源代码安装"><a href="#方法1-源代码安装" class="headerlink" title="方法1.源代码安装"></a>方法1.源代码安装</h2><p>Twisted默认源代码安装需要在本地编译c代码，需要安装VC</p><pre><code>pip install twisted</code></pre><h2 id="方法2-第三方预编译包"><a href="#方法2-第三方预编译包" class="headerlink" title="方法2.第三方预编译包"></a>方法2.第三方预编译包</h2><p><a href="https://www.lfd.uci.edu网站上提供了大非官方提供的windows平台二进制python包,很多无法直接安装的库可以在这里找到平台专用包./">https://www.lfd.uci.edu网站上提供了大非官方提供的windows平台二进制python包，很多无法直接安装的库可以在这里找到平台专用包。</a></p><p>打开该页面，Ctrl+F打开搜索框，输入要查找的包名称即可快速找到安装包。</p><p>twisted的版本如下。</p><p><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted">https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted</a></p><p>截至发稿最新版本Twisted19.2.1的安装包连接如下</p><h3 id="python27-Win64"><a href="#python27-Win64" class="headerlink" title="python27 Win64"></a>python27 Win64</h3><pre><code>pip install https://download.lfd.uci.edu/pythonlibs/t4jqbe6o/Twisted-19.2.1-cp27-cp27m-win_amd64.whl</code></pre><h3 id="python27-Win32"><a href="#python27-Win32" class="headerlink" title="python27 Win32"></a>python27 Win32</h3><pre><code>pip install https://download.lfd.uci.edu/pythonlibs/t4jqbe6o/Twisted-19.2.1-cp27-cp27m-win32.whl</code></pre><h3 id="python37-Win64"><a href="#python37-Win64" class="headerlink" title="python37 Win64"></a>python37 Win64</h3><pre><code>pip install https://download.lfd.uci.edu/pythonlibs/t4jqbe6o/Twisted-19.2.1-cp37-cp37m-win_amd64.whl</code></pre><h3 id="python37-Win32"><a href="#python37-Win32" class="headerlink" title="python37 Win32"></a>python37 Win32</h3><pre><code>pip install https://download.lfd.uci.edu/pythonlibs/t4jqbe6o/Twisted-19.2.1-cp37-cp37m-win32.whl</code></pre><p>其他版本可以自行查找下载。</p><h2 id="方法3-推荐）"><a href="#方法3-推荐）" class="headerlink" title="方法3(推荐）"></a>方法3(推荐）</h2><p>官方最新提供了支持pip安装方式，如下</p><pre><code>pip install Twisted[windows_platform]</code></pre><p>一键安装，从此无烦恼。</p><h2 id="Microsoft-Visual-C-14-0-is-required"><a href="#Microsoft-Visual-C-14-0-is-required" class="headerlink" title="Microsoft Visual C++ 14.0 is required"></a>Microsoft Visual C++ 14.0 is required</h2><p>如果在安装过程中提示错误:</p><pre><code>error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Microsoft Visual C++ Build Tools&quot;: https://visualstudio.microsoft.com/downloads/</code></pre><p>可以在<a href="http://go.microsoft.com/fwlink/?LinkId=691126&fixForIE=.exe.">这里</a>下载Visual C++ 2015(14.0) Build Tools.</p><p>see: </p><ul><li><a href="https://www.scivision.dev/python-windows-visual-c-14-required/">https://www.scivision.dev/python-windows-visual-c-14-required/</a></li><li><a href="https://stackoverflow.com/questions/29846087/microsoft-visual-c-14-0-is-required-unable-to-find-vcvarsall-bat">https://stackoverflow.com/questions/29846087/microsoft-visual-c-14-0-is-required-unable-to-find-vcvarsall-bat</a></li></ul><h2 id="小彩蛋"><a href="#小彩蛋" class="headerlink" title="小彩蛋"></a>小彩蛋</h2><p>通过twisted可以快速建立各种简易的网络服务器，比如启动一个本地测试用的FTP服务器代码如下：</p><p>ftpserver.py:</p><pre><code># Copyright (c) Twisted Matrix Laboratories.# See LICENSE for details.&quot;&quot;&quot;An example FTP server with minimal user authentication.&quot;&quot;&quot;from twisted.protocols.ftp import FTPFactory, FTPRealm, BaseFTPRealmfrom twisted.cred.portal import Portalfrom twisted.cred.checkers import AllowAnonymousAccess, FilePasswordDBfrom twisted.internet import reactorfrom twisted.python import log, failure, filepath&quot;&quot;&quot;An example FTP server with minimal user authentication.&quot;&quot;&quot;## First, set up a portal (twisted.cred.portal.Portal). This will be used# to authenticate user logins, including anonymous logins.## Part of this will be to establish the &quot;realm&quot; of the server - the most# important task in this case is to establish where anonymous users will# have default access to. In a real world scenario this would typically# point to something like &#39;/pub&#39; but for this example it is pointed at the# current working directory.## The other important part of the portal setup is to point it to a list of# credential checkers. In this case, the first of these is used to grant# access to anonymous users and is relatively simple; the second is a very# primitive password checker.  This example uses a plain text password file# that has one username:password pair per line. This checker *does* provide# a hashing interface, and one would normally want to use it instead of# plain text storage for anything remotely resembling a &#39;live&#39; network. In# this case, the file &quot;pass.dat&quot; is used, and stored in the same directory# as the server. BAD.## Create a pass.dat file which looks like this:## =====================#   jeff:bozo#   grimmtooth:bozo2# =====================class LocalFTPRealm(BaseFTPRealm):    def __init__(self):        self.userHome = filepath.FilePath(&#39;./HOME&#39;)               def getHomeDirectory(self, avatarId):        return self.userHomep = Portal(LocalFTPRealm(),           [AllowAnonymousAccess(), FilePasswordDB(&#39;./auth&#39;, cache=True)])## Once the portal is set up, start up the FTPFactory and pass the portal to# it on startup. FTPFactory will start up a twisted.protocols.ftp.FTP()# handler for each incoming OPEN request. Business as usual in Twisted land.#f = FTPFactory(p)## You know this part. Point the reactor to port 21 coupled with the above factory,# and start the event loop.#reactor.listenTCP(21, f)reactor.run()</code></pre><p>ftp同一文件夹下创建一个auth文件，每行一个用户，用户名和密码用冒号:分割。</p><p>auth:</p><pre><code>abc:123</code></pre><p>FTP根目录对应当前文件夹下的HOME文件夹，Enjoy.</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vagrant vboxsf error的解决方法</title>
      <link href="/2019/06/28/vagrant-vboxsf-error/"/>
      <url>/2019/06/28/vagrant-vboxsf-error/</url>
      
        <content type="html"><![CDATA[<h1 id="出错情况"><a href="#出错情况" class="headerlink" title="出错情况"></a>出错情况</h1><p>以前一直用的一个vagrant环境，突然启动出现问题。<br>vagrant 运行在windows上，vagrant 启动centos7虚拟机，vagrant up时提示错误，无法将host上的文件夹映射到虚拟机里。</p><p>错误信息如下:</p><pre><code>Vagrant was unable to mount VirtualBox shared folders. This is usuallybecause the filesystem &quot;vboxsf&quot; is not available. This filesystem ismade available via the VirtualBox Guest Additions and kernel module.Please verify that these guest additions are properly installed in theguest. This is not a bug in Vagrant and is usually caused by a faultyVagrant box. For context, the command attempted was:mount -t vboxsf -o uid=1000,gid=1000 vagrant /vagrantThe error output from the command was:/sbin/mount.vboxsf: mounting failed with the error: No such device</code></pre><h2 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h2><p>先ssh连进guest</p><pre><code>vagrant ssh</code></pre><p>然后</p><pre><code>cd /opt/VBoxGuestAdditions-*/init  sudo ./vboxadd setup</code></pre><p>提示信息</p><pre><code>VirtualBox Guest Additions: Building the VirtualBox Guest Additions kernel modules.  This may take a while.grep: Unmatched ) or \)This system is currently not set up to build kernel modules.Please install the Linux kernel &quot;header&quot; files matching the current kernelfor adding new hardware support to the system.The distribution packages containing the headers are probably:    kernel-devel kernel-devel-3.10.0-957.21.3.el7.x86_64VirtualBox Guest Additions: Starting.VirtualBox Guest Additions: Building the VirtualBox Guest Additions kernel modules.  This may take a while.grep: Unmatched ) or \)This system is currently not set up to build kernel modules.Please install the Linux kernel &quot;header&quot; files matching the current kernelfor adding new hardware support to the system.The distribution packages containing the headers are probably:    kernel-devel kernel-devel-3.10.0-957.21.3.el7.x86_64modprobe vboxguest failedThe log file /var/log/vboxadd-setup.log may contain further information.</code></pre><p>安装kernel</p><pre><code>sudo yum install kernel-devel kernel-devel-3.10.0-957.21.3.el7.x86_64</code></pre><p>重新运行 .&#x2F;vboxadd setup 提示错误</p><pre><code>VirtualBox Guest Additions: Building the VirtualBox Guest Additions kernel modules.  This may take a while.grep: Unmatched ) or \)VirtualBox Guest Additions: Look at /var/log/vboxadd-setup.log to find out what went wrongVirtualBox Guest Additions: Starting.</code></pre><p>&#x2F;var&#x2F;log&#x2F;vboxadd-setup.log:</p><pre><code>Building the main Guest Additions module.Building the shared folder support module.Building the graphics driver module.Error building the module:Could not find the X.Org or XFree86 Window System, skipping.</code></pre><p>在虚拟机中安装xorg</p><pre><code>yum -y install xorg-x11-drivers xorg-x11-utils</code></pre><p>在host上安装vbguest插件</p><pre><code>vagrant plugin install vagrant-vbguest</code></pre><p>重新启动虚拟机，问题解决</p><pre><code>vagrant reload</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 写代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Zset 实现原理</title>
      <link href="/2019/06/28/Redis-Zset-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/28/Redis-Zset-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-TTL"><a href="#Redis-TTL" class="headerlink" title="Redis TTL"></a>Redis TTL</h1><p>Redis 只在key一级上有TTL (Time to live) 机制，<a href="https://redis.io/commands/expire" title="Expire Command">https://redis.io/commands/expire</a>，有的时候我们需要把item按某种顺序排序，如排行榜或移动时间窗口，这个时候使用Sorted Set(Zset)就非常有用了。</p><h1 id="Redis-Zset-按时间过期机制"><a href="#Redis-Zset-按时间过期机制" class="headerlink" title="Redis Zset 按时间过期机制"></a>Redis Zset 按时间过期机制</h1><p>_1. zadd 添加item时设置score为当前unixtime<br>__1.1. 如果只以第一次插入时间戳做删除则指定nx&#x3D;true, <a href="https://redis.io/commands/zadd">https://redis.io/commands/zadd</a><br>__1.2. 如果需要更新已经存在item时间戳为当前时间TTL则指定默认选项，score设置为当前unittime<br>__1.3. 如果每次需要延长固定时间，检查item存在时使用ZINCRBY命令<br>_2. 定时做清理任务，每次计算删除某个时间点之前的所有item  zremrangebyscore</p><h1 id="Redis-Zset-命令时间复杂度"><a href="#Redis-Zset-命令时间复杂度" class="headerlink" title="Redis Zset 命令时间复杂度"></a>Redis Zset 命令时间复杂度</h1><p>Command Complexities of Zset and Set</p><p>|                      | Zset        | Set  |<br>|———————-|————-|——|<br>| Add                  | O(log(N))   | O(1) |<br>| Delete (1 items)     | O(log(N))   | O(1) |<br>| Iterate items by key | O(log(N)+M) | O(N) |<br>| Scan by score        | O(log(N)+M) | N&#x2F;A  |</p><p>可以看出zset单个元素操作一般为Log(N)其中N为当前集合元素个数。</p><h1 id="Redis-Zset-底层结构及算法实现"><a href="#Redis-Zset-底层结构及算法实现" class="headerlink" title="Redis Zset 底层结构及算法实现"></a>Redis Zset 底层结构及算法实现</h1><p>与set无顺序存储不同，Zset按score顺序进行存储，这也是为什么基本操作都是O(log(N))复杂度。</p><p>Redis使用两种结构存储zset，在数据个数较少时使用ziplist，数量超出阈值时使用skiplist，阈值通过zset-max-ziplist-entries and zset-max-ziplist-value设置。</p><h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><p>ziplist使用连续空间存储双向链表，相比基于堆空间指针的链表前后向移动速度更快。</p><p><img src="https://redislabs.com/wp-content/images/academy/redis-in-action/RIA_fig9-01.svg"></p><p>reids list也是使用ziplist存储。</p><h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><p>skiplist 跳跃列表:</p><pre><code>/* ZSETs use a specialized version of Skiplists */typedef struct zskiplistNode &#123;    sds ele;    double score;    struct zskiplistNode *backward;    struct zskiplistLevel &#123;        struct zskiplistNode *forward;        unsigned long span;    &#125; level[];&#125; zskiplistNode;typedef struct zskiplist &#123;    struct zskiplistNode *header, *tail;    unsigned long length;    int level;&#125; zskiplist;typedef struct zset &#123;    dict *dict;    zskiplist *zsl;&#125; zset;</code></pre><p>跳跃列表保存一个有序排列的链表，通过采用多层存储且保持每一层链表是其上一层链表的自己，从最稀疏的层开始搜索，从而达到比链表O(N)更优的查找和插入性能O(log(N))。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Skip_list_add_element-en.gif/600px-Skip_list_add_element-en.gif"></p><p>具体说明参见<a href="https://en.wikipedia.org/wiki/Skip_list">wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
